class MarkdownFormatter {
  static format(report) {
    const markdown = `
# Smart AST Analysis Report

**Generated:** ${new Date(report.timestamp).toLocaleString()}  
**Project:** ${report.projectInfo.path}  
**Framework:** ${report.projectInfo.framework}  
**Language:** ${report.projectInfo.language}  

## Executive Summary

${report.summary}

## Project Overview

- **Type:** ${report.projectInfo.type}
- **Language:** ${report.projectInfo.language}
- **Framework:** ${report.projectInfo.framework}
- **Total Files:** ${report.projectInfo.metrics?.totalFiles || 'Unknown'}
- **Total Lines:** ${report.projectInfo.metrics?.totalLines || 'Unknown'}
- **Dependencies:** ${report.projectInfo.dependencies?.total || 0}

## Analysis Results

${this.formatAnalysisResults(report.results)}

## Key Insights

${report.insights.map(insight => `- ${insight}`).join('\n')}

## Recommendations

${this.formatRecommendations(report.recommendations)}

## Metrics Summary

${this.formatMetrics(report.metrics)}

---

*Generated by Smart AST Analyzer v${require('../../package.json').version}*
    `;
    
    return markdown.trim();
  }

  static formatAnalysisResults(results) {
    let output = '';
    
    for (const [type, data] of Object.entries(results)) {
      output += this.formatResultSection(type, data);
    }
    
    return output;
  }

  static formatResultSection(type, data) {
    const formatters = {
      api: this.formatAPIResults.bind(this),
      components: this.formatComponentResults.bind(this),
      websocket: this.formatWebSocketResults.bind(this),
      auth: this.formatAuthResults.bind(this),
      database: this.formatDatabaseResults.bind(this),
      performance: this.formatPerformanceResults.bind(this)
    };
    
    const formatter = formatters[type];
    if (!formatter) return '';
    
    return formatter(data);
  }

  static formatAPIResults(data) {
    if (!data.endpoints) return '';
    
    return `
### API Endpoints

**Total Endpoints:** ${data.endpoints.length}

#### Endpoint Summary
| Method | Path | Handler | Auth Required | Issues |
|--------|------|---------|---------------|--------|
${data.endpoints.slice(0, 20).map(endpoint => 
  `| ${endpoint.method} | \`${endpoint.path}\` | ${endpoint.handler} | ${endpoint.auth?.required ? 'Yes' : 'No'} | ${endpoint.issues?.length || 0} |`
).join('\n')}

${data.securityIssues?.length ? `
#### Security Issues
${data.securityIssues.map(issue => 
  `- **${issue.severity.toUpperCase()}**: ${issue.issue} (${issue.endpoint})`
).join('\n')}
` : ''}

${data.orphanedEndpoints?.length ? `
#### Orphaned Endpoints
${data.orphanedEndpoints.map(endpoint => `- \`${endpoint}\``).join('\n')}
` : ''}
    `;
  }

  static formatComponentResults(data) {
    if (!data.components) return '';
    
    const componentCount = Object.keys(data.components).length;
    
    return `
### Component Architecture

**Total Components:** ${componentCount}

#### Component Summary
${Object.entries(data.components).slice(0, 10).map(([name, comp]) => `
**${name}**
- File: \`${comp.file}\`
- Type: ${comp.type}
- Props: ${Object.keys(comp.props || {}).length}
- Issues: ${comp.issues?.length || 0}
`).join('\n')}

${data.unusedComponents?.length ? `
#### Unused Components
${data.unusedComponents.map(comp => `- \`${comp}\``).join('\n')}
` : ''}

${data.circularDependencies?.length ? `
#### Circular Dependencies
${data.circularDependencies.map(cycle => `- ${cycle.join(' â†’ ')}`).join('\n')}
` : ''}
    `;
  }

  static formatWebSocketResults(data) {
    if (!data.events) return '';
    
    const clientEvents = Object.keys(data.events.client || {}).length;
    const serverEvents = Object.keys(data.events.server || {}).length;
    
    return `
### WebSocket Events

**Client Events:** ${clientEvents}  
**Server Events:** ${serverEvents}

#### Event Summary
${Object.entries(data.events.client || {}).slice(0, 10).map(([name, event]) => 
  `- **${name}**: ${event.file} (Line ${event.line})`
).join('\n')}

${data.issues?.security?.length ? `
#### Security Issues
${data.issues.security.map(issue => `- ${issue}`).join('\n')}
` : ''}
    `;
  }

  static formatAuthResults(data) {
    if (!data.authentication) return '';
    
    return `
### Authentication & Authorization

**Auth Methods:** ${data.authentication.methods?.join(', ') || 'None'}  
**Authorization Type:** ${data.authorization?.type || 'Unknown'}  
**Protected Routes:** ${data.protectedRoutes?.length || 0}

#### Security Analysis
${data.security?.vulnerabilities?.map(vuln => 
  `- **${vuln.severity.toUpperCase()}**: ${vuln.description}`
).join('\n') || 'No vulnerabilities found'}
    `;
  }

  static formatDatabaseResults(data) {
    if (!data.models) return '';
    
    return `
### Database Analysis

**Models:** ${data.models.length}  
**Query Performance Issues:** ${data.performance?.nPlusOneQueries?.length || 0}

#### Model Summary
${data.models.slice(0, 10).map(model => 
  `- **${model.name}**: ${model.fields?.length || 0} fields, ${model.relationships?.length || 0} relationships`
).join('\n')}

${data.performance?.nPlusOneQueries?.length ? `
#### Performance Issues
${data.performance.nPlusOneQueries.map(issue => `- ${issue.description}`).join('\n')}
` : ''}
    `;
  }

  static formatPerformanceResults(data) {
    return `
### Performance Analysis

#### Bundle Analysis
${data.bundle?.largeDependencies?.length ? `
**Large Dependencies:**
${data.bundle.largeDependencies.map(dep => `- ${dep.name}: ${dep.size}`).join('\n')}
` : ''}

#### Rendering Performance
${data.rendering?.heavyComponents?.length ? `
**Heavy Components:**
${data.rendering.heavyComponents.map(comp => `- ${comp.name}: ${comp.issues?.join(', ')}`).join('\n')}
` : ''}

#### Optimization Opportunities
${data.optimization?.immediate?.length ? `
**Immediate:**
${data.optimization.immediate.map(opt => `- ${opt}`).join('\n')}
` : ''}
    `;
  }

  static formatRecommendations(recommendations) {
    return recommendations.map((rec, i) => `
### ${i + 1}. ${rec.title}

${rec.description}

**Priority:** ${rec.priority}  
**Effort:** ${rec.effort}  
**Impact:** ${rec.impact}
`).join('\n');
  }

  static formatMetrics(metrics) {
    return `
| Metric | Value |
|--------|-------|
| Total Files Analyzed | ${metrics.totalFiles || 0} |
| Code Quality Score | ${metrics.codeQuality || 'N/A'} |
| Security Score | ${metrics.securityScore || 'N/A'} |
| Performance Score | ${metrics.performanceScore || 'N/A'} |
| Maintainability | ${metrics.maintainability || 'N/A'} |
    `;
  }
}

module.exports = MarkdownFormatter;